#!/usr/bin/env python3
# Embed JCC-specific headers into std.c
# These headers are tightly coupled to the VM and must be embedded

import os
import sys

def main():
    include_dir = "include"
    output_file = "src/std.c"
    
    if not os.path.exists(include_dir):
        print(f"Error: {include_dir} not found")
        sys.exit(1)

    headers = []
    
    # Collect headers from include directory
    for root, dirs, files in os.walk(include_dir):
        for f in files:
            if f.endswith(".h"):
                # Get relative path from include/ directory
                rel_path = os.path.relpath(os.path.join(root, f), include_dir)
                headers.append(rel_path)
    
    headers.sort()
    
    with open(output_file, "w") as out:
        out.write('/* Auto-generated by std.py - DO NOT EDIT */\n')
        out.write('#include <string.h>\n\n')
        
        # Write content variables
        for h in headers:
            var_name = "std_" + h.replace("/", "_").replace(".", "_")
            full_path = os.path.join(include_dir, h)
            with open(full_path, "rb") as f:
                content = f.read()
            
            out.write(f'static const char {var_name}[] = {{\n')
            
            # Use byte array instead of string literal to avoid parser limits and hex escaping issues
            for i, val in enumerate(content):
                out.write(f'0x{val:02x}, ')
                if (i + 1) % 12 == 0:
                    out.write('\n')
            
            out.write('0x00\n};\n\n')
            
        out.write('char *get_std_header(char *filename) {\n')
        for h in headers:
            var_name = "std_" + h.replace("/", "_").replace(".", "_")
            out.write(f'    if (strcmp(filename, "{h}") == 0) return (char*){var_name};\n')
        out.write('    return NULL;\n')
        out.write('}\n')
    
    print(f"Generated {output_file} from {len(headers)} headers.")

if __name__ == "__main__":
    main()
