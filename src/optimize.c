/*
 JCC: JIT C Compiler

 Copyright (C) 2025 George Watson

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#include "jcc.h"
#include "./internal.h"

//
// Bytecode Optimizer
//
// This module implements optional optimization passes on the generated bytecode.
// The optimizer runs after codegen and before execution, operating on the
// text_seg[] array of instructions.
//
// Optimization Levels:
//   -O0: No optimization (default)
//   -O1: Basic - constant folding
//   -O2: Standard - constant folding + peephole
//   -O3: Aggressive - all passes including dead code elimination
//

// ========== Helper Functions ==========

// Get opcode from instruction at pc
static int get_opcode(long long *pc) {
    return (int)*pc;
}

// Check if opcode is a 2-word instruction (op + operand)
static bool is_2word_op(int op) {
    // Most register ops have operands encoded in the second word
    switch (op) {
        case JMP:
        case CALL:
        case JMPT:
        case JMPI:
            return true;
        default:
            // Check for register-based ops (all 3-reg/2-reg/1-reg ops have operand word)
            return op >= ADD3;  // All new register ops are >= ADD3
    }
}

// Check if opcode uses an immediate value (3-word: op + operand + imm)
static bool is_3word_op(int op) {
    switch (op) {
        case LI3:    // rd + imm
        case LEA3:   // rd + imm
        case ADDI3:  // rd, rs + imm
        case JZ3:    // rs + target
        case JNZ3:   // rs + target
            return true;
        default:
            return false;
    }
}

// Get instruction size in words
static int get_instr_size(int op) {
    if (is_3word_op(op)) return 3;
    if (is_2word_op(op)) return 2;
    return 1;
}

// ========== Pass 1: Constant Folding ==========
//
// Fold arithmetic operations on constant values at compile time.
// Pattern: LI3 rx, A; LI3 ry, B; OP3 rz, rx, ry -> LI3 rz, (A OP B)
//
// We use a simple value tracking approach:
// - Track which registers hold known constant values
// - When we see an arithmetic op with two constant operands, fold it
// - Replace the instruction sequence with a single LI3
//

// Maximum registers to track
#define MAX_TRACKED_REGS 32

// Track constant values in registers
typedef struct {
    bool is_const[MAX_TRACKED_REGS];
    long long value[MAX_TRACKED_REGS];
} RegState;

// Reset register state (e.g., at function boundaries, jumps)
static void reset_reg_state(RegState *state) {
    for (int i = 0; i < MAX_TRACKED_REGS; i++) {
        state->is_const[i] = false;
        state->value[i] = 0;
    }
}

// NOP instruction (replace folded instructions with this)
// We'll use LI3 r0, 0 as NOP since r0 is the zero register (writes discarded)
#define NOP_OP LI3
#define NOP_RD 0
#define NOP_IMM 0

// Emit a NOP at the given location (for 2-word instructions)
static void emit_nop_2word(long long *pc) {
    // Just leave as-is for now, we could mark for removal in a compaction pass
    // For now, we'll convert to LI3 r0, 0 which has no effect
    (void)pc;
}

// Emit a NOP at the given location (for 3-word instructions)  
static void emit_nop_3word(long long *pc) {
    pc[0] = NOP_OP;
    pc[1] = ENCODE_R(NOP_RD);
    pc[2] = NOP_IMM;
}

static void opt_constant_fold(JCC *vm) {
    if (!vm || !vm->text_seg || !vm->text_ptr) {
        return;
    }

    RegState state;
    reset_reg_state(&state);

    long long *start = vm->text_seg + 1;  // Skip entry point at text_seg[0]
    long long *end = vm->text_ptr;
    long long *pc = start;

    int folded_count = 0;

    while (pc < end) {
        int op = get_opcode(pc);
        int size = get_instr_size(op);

        switch (op) {
            case LI3: {
                // LI3 rd, imm - register gets constant value
                int rd = pc[1] & 0xFF;
                long long imm = pc[2];
                if (rd < MAX_TRACKED_REGS && rd != 0) {
                    state.is_const[rd] = true;
                    state.value[rd] = imm;
                }
                break;
            }

            case ADD3:
            case SUB3:
            case MUL3:
            case DIV3:
            case MOD3:
            case AND3:
            case OR3:
            case XOR3:
            case SHL3:
            case SHR3:
            case SEQ3:
            case SNE3:
            case SLT3:
            case SGE3:
            case SGT3:
            case SLE3: {
                // OP3 rd, rs1, rs2 - check if both operands are constants
                int rd, rs1, rs2;
                DECODE_RRR(pc[1], rd, rs1, rs2);

                if (rs1 < MAX_TRACKED_REGS && rs2 < MAX_TRACKED_REGS &&
                    state.is_const[rs1] && state.is_const[rs2] &&
                    rd != 0) {
                    
                    long long a = state.value[rs1];
                    long long b = state.value[rs2];
                    long long result = 0;
                    bool can_fold = true;

                    switch (op) {
                        case ADD3: result = a + b; break;
                        case SUB3: result = a - b; break;
                        case MUL3: result = a * b; break;
                        case DIV3:
                            if (b == 0) can_fold = false;  // Don't fold div by zero
                            else result = a / b;
                            break;
                        case MOD3:
                            if (b == 0) can_fold = false;
                            else result = a % b;
                            break;
                        case AND3: result = a & b; break;
                        case OR3:  result = a | b; break;
                        case XOR3: result = a ^ b; break;
                        case SHL3: result = a << b; break;
                        case SHR3: result = (unsigned long long)a >> b; break;
                        case SEQ3: result = (a == b) ? 1 : 0; break;
                        case SNE3: result = (a != b) ? 1 : 0; break;
                        case SLT3: result = (a < b) ? 1 : 0; break;
                        case SGE3: result = (a >= b) ? 1 : 0; break;
                        case SGT3: result = (a > b) ? 1 : 0; break;
                        case SLE3: result = (a <= b) ? 1 : 0; break;
                        default: can_fold = false; break;
                    }

                    if (can_fold) {
                        // Replace this 2-word OP3 with 3-word LI3
                        // We can only do this if there's room (we have 2 words, need 3)
                        // For now, just update the result register's known value
                        // A more sophisticated approach would restructure the bytecode
                        state.is_const[rd] = true;
                        state.value[rd] = result;
                        
                        // Convert OP3 to LI3 in place
                        // Problem: OP3 is 2 words, LI3 is 3 words
                        // Solution: Look backwards for the LI3 that loaded rs1 or rs2
                        // and replace the whole sequence
                        // For now, let's just track the constant but not rewrite
                        // (Full rewrite requires more complex code motion)
                        folded_count++;
                    }
                } else {
                    // Result is not a constant
                    if (rd < MAX_TRACKED_REGS) {
                        state.is_const[rd] = false;
                    }
                }
                break;
            }

            case MOV3: {
                // MOV3 rd, rs - copy constant status
                int rd = pc[1] & 0xFF;
                int rs = (pc[1] >> 8) & 0xFF;
                if (rd < MAX_TRACKED_REGS && rd != 0) {
                    if (rs < MAX_TRACKED_REGS && state.is_const[rs]) {
                        state.is_const[rd] = true;
                        state.value[rd] = state.value[rs];
                    } else {
                        state.is_const[rd] = false;
                    }
                }
                break;
            }

            case NEG3:
            case NOT3:
            case BNOT3: {
                // Unary ops: rd = OP(rs)
                int rd = pc[1] & 0xFF;
                int rs = (pc[1] >> 8) & 0xFF;
                if (rd < MAX_TRACKED_REGS && rd != 0) {
                    if (rs < MAX_TRACKED_REGS && state.is_const[rs]) {
                        long long val = state.value[rs];
                        if (op == NEG3) val = -val;
                        else if (op == NOT3) val = !val;
                        else if (op == BNOT3) val = ~val;
                        state.is_const[rd] = true;
                        state.value[rd] = val;
                    } else {
                        state.is_const[rd] = false;
                    }
                }
                break;
            }

            case ADDI3: {
                // ADDI3 rd, rs, imm - if rs is const, result is const
                int rd = pc[1] & 0xFF;
                int rs = (pc[1] >> 8) & 0xFF;
                long long imm = pc[2];
                if (rd < MAX_TRACKED_REGS && rd != 0) {
                    if (rs < MAX_TRACKED_REGS && state.is_const[rs]) {
                        state.is_const[rd] = true;
                        state.value[rd] = state.value[rs] + imm;
                    } else {
                        state.is_const[rd] = false;
                    }
                }
                break;
            }

            // Control flow - invalidate all tracked constants
            case JMP:
            case JZ3:
            case JNZ3:
            case JMPT:
            case JMPI:
            case CALL:
            case CALLI:
            case ENT3:
            case LEV3:
                reset_reg_state(&state);
                break;

            // Loads from memory - result is not constant
            case LDR_B:
            case LDR_H:
            case LDR_W:
            case LDR_D:
            case FLDR: {
                int rd = pc[1] & 0xFF;
                if (rd < MAX_TRACKED_REGS) {
                    state.is_const[rd] = false;
                }
                break;
            }

            // Function calls clobber return registers
            case CALLF:
                if (REG_A0 < MAX_TRACKED_REGS) state.is_const[REG_A0] = false;
                break;

            default:
                // For other instructions, conservatively invalidate destination if any
                // Most will have dest in low 8 bits if present
                break;
        }

        pc += size;
    }

    if (vm->debug_vm && folded_count > 0) {
        printf("[opt] constant folding: tracked %d constant expressions\n", folded_count);
    }
}

// ========== Pass 2: Peephole Optimization ==========
//
// Pattern match and remove redundant instruction sequences.
// Uses a sliding window approach with pattern matching.
//
// Patterns:
// 1. MOV3 ra, ra -> NOP (self-move)
// 2. LI3 rx, A; LI3 rx, B -> LI3 rx, B (overwritten load)
// 3. PSH3 rx; POP3 rx -> NOP (push/pop same register)
// 4. JMP to next instruction -> NOP
//

// Mark an instruction as NOP (for later removal or skipping)
// For 2-word instructions: convert to MOV3 r0, r0 (effectively NOP)
static void nop_2word(long long *pc) {
    pc[0] = MOV3;
    pc[1] = ENCODE_RR(0, 0);  // MOV3 r0, r0 = NOP
}

// For 3-word instructions: convert to LI3 r0, 0 (effectively NOP) 
static void nop_3word(long long *pc) {
    pc[0] = LI3;
    pc[1] = ENCODE_R(0);
    pc[2] = 0;  // LI3 r0, 0 = NOP
}

static void opt_peephole(JCC *vm) {
    if (!vm || !vm->text_seg || !vm->text_ptr) {
        return;
    }

    long long *start = vm->text_seg + 1;  // Skip entry point
    long long *end = vm->text_ptr;
    int opt_count = 0;

    // Pattern 1: MOV3 ra, ra -> NOP (self-move)
    for (long long *pc = start; pc < end; ) {
        int op = get_opcode(pc);
        int size = get_instr_size(op);

        if (op == MOV3) {
            int rd = pc[1] & 0xFF;
            int rs = (pc[1] >> 8) & 0xFF;
            if (rd == rs && rd != 0) {
                // Self-move - convert to NOP
                nop_2word(pc);
                opt_count++;
            }
        }
        pc += size;
    }

    // Pattern 2: LI3 rx, A; LI3 rx, B -> NOP; LI3 rx, B (dead store)
    for (long long *pc = start; pc < end; ) {
        int op = get_opcode(pc);
        int size = get_instr_size(op);

        if (op == LI3 && pc + size < end) {
            long long *next = pc + size;
            int next_op = get_opcode(next);
            if (next_op == LI3) {
                int rd1 = pc[1] & 0xFF;
                int rd2 = next[1] & 0xFF;
                if (rd1 == rd2 && rd1 != 0) {
                    // Second LI3 overwrites first - first is dead
                    nop_3word(pc);
                    opt_count++;
                }
            }
        }
        pc += size;
    }

    // Pattern 3: PSH3 rx; POP3 rx -> NOP; NOP (useless push/pop)
    for (long long *pc = start; pc < end; ) {
        int op = get_opcode(pc);
        int size = get_instr_size(op);

        if (op == PSH3 && pc + size < end) {
            long long *next = pc + size;
            int next_op = get_opcode(next);
            if (next_op == POP3) {
                int rs_push = pc[1] & 0xFF;
                int rd_pop = next[1] & 0xFF;
                if (rs_push == rd_pop) {
                    // Push then pop same register - useless
                    nop_2word(pc);
                    nop_2word(next);
                    opt_count++;
                }
            }
        }
        pc += size;
    }

    // Pattern 4: JMP to next instruction -> NOP
    for (long long *pc = start; pc < end; ) {
        int op = get_opcode(pc);
        int size = get_instr_size(op);

        if (op == JMP) {
            long long target = pc[1];
            long long *next = pc + size;
            if (target == (long long)next) {
                // Jump to the very next instruction - useless
                nop_2word(pc);
                opt_count++;
            }
        }
        pc += size;
    }

    // Pattern 5: MOV3 ra, rb; MOV3 rb, ra -> MOV3 ra, rb (second is nop if rb not used)
    // This is more complex - skip for now

    if (vm->debug_vm && opt_count > 0) {
        printf("[opt] peephole: removed %d redundant instructions\n", opt_count);
    }
}

// ========== Pass 3: Dead Code Elimination ==========
//
// Remove clearly unreachable code - conservative approach.
// Only remove code that is demonstrably dead without complex analysis.
//
// Current implementation: Just count NOP sequences from previous passes.
// Actual code removal requires careful jump target tracking which is complex.
//
// Safe patterns we can detect:
// 1. Consecutive identical LI3 to same reg (second overwrites first)
// 2. Store followed immediately by another store to same address
//

static void opt_dead_code(JCC *vm) {
    if (!vm || !vm->text_seg || !vm->text_ptr) {
        return;
    }

    long long *start = vm->text_seg + 1;  // Skip entry point
    long long *end = vm->text_ptr;
    int dce_count = 0;

    // Count NOPs created by previous passes (informational only)
    int nop_count = 0;
    for (long long *pc = start; pc < end; ) {
        int op = get_opcode(pc);
        int size = get_instr_size(op);

        // Check if this is a NOP
        if (op == MOV3) {
            int rd = pc[1] & 0xFF;
            int rs = (pc[1] >> 8) & 0xFF;
            if (rd == 0 && rs == 0) nop_count++;
        } else if (op == LI3) {
            int rd = pc[1] & 0xFF;
            if (rd == 0 && pc[2] == 0) nop_count++;
        }
        pc += size;
    }

    // Pattern: MOV3 rd, rs followed by another MOV3 rd, rx -> first is dead
    // (if rd is overwritten before being read)
    for (long long *pc = start; pc < end; ) {
        int op = get_opcode(pc);
        int size = get_instr_size(op);

        if (op == MOV3 && pc + size < end) {
            int rd1 = pc[1] & 0xFF;
            long long *next = pc + size;
            int next_op = get_opcode(next);
            
            if (next_op == MOV3) {
                int rd2 = next[1] & 0xFF;
                if (rd1 == rd2 && rd1 != 0) {
                    // Consecutive MOV3 to same register - first is dead
                    nop_2word(pc);
                    dce_count++;
                }
            }
        }
        pc += size;
    }

    if (vm->debug_vm && (dce_count > 0 || nop_count > 0)) {
        printf("[opt] dead code: %d instructions removed, %d NOPs present\n", 
               dce_count, nop_count);
    }
}

// ========== Main Entry Point ==========

void cc_optimize(JCC *vm, int level) {
    if (!vm || !vm->text_seg || level <= 0) {
        return;
    }

    // Level 1: Basic optimization (constant folding)
    if (level >= 1) {
        opt_constant_fold(vm);
    }

    // Level 2: Standard optimization (+ peephole)
    if (level >= 2) {
        opt_peephole(vm);
    }

    // Level 3: Aggressive optimization (+ dead code elimination)
    if (level >= 3) {
        opt_dead_code(vm);
    }
}
