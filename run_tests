#!/usr/bin/env bash
# Test runner for JCC 
# Runs all test_*.c files in tests/ directory and reports results

script_dir=$(cd "$(dirname "$0")" && pwd)
jcc="$script_dir/jcc"
tests_dir="$script_dir/tests"

# Detect platform for memory leak detection
detect_platform() {
    case "$(uname -s)" in
        Darwin*)
            echo "macos"
            ;;
        Linux*)
            echo "linux"
            ;;
        CYGWIN*|MINGW*|MSYS*)
            echo "windows"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

platform=$(detect_platform)

# Check if jcc exists
if [ ! -f "$jcc" ]; then
    echo "Error: jcc executable not found. Please run 'make' first."
    exit 1
fi

# Check if tests directory exists
if [ ! -d "$tests_dir" ]; then
    echo "Error: tests directory not found."
    exit 1
fi

# Initialize counters
passed=0
failed=0
crashed=0
total=0
negative_passed=0
negative_failed=0
failed_tests=()
crashed_tests=()

# Get all test files
test_files=()
while IFS= read -r file; do
    [ -n "$file" ] && test_files+=("$file")
done < <(find "$tests_dir" -name "test_*.c" -maxdepth 1 | sort)

# Parse arguments
use_leaks=0
match_pattern=""
jcc_args=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --leaks)
            use_leaks=1
            shift
            ;;
        --match)
            match_pattern="$2"
            shift 2
            ;;
        *)
            jcc_args+=("$1")
            shift
            ;;
    esac
done

# Filter tests by match pattern if provided
if [ -n "$match_pattern" ]; then
    filtered_tests=()
    for test_file in "${test_files[@]}"; do
        test_name=$(basename "$test_file")
        # Use bash pattern matching
        if [[ $test_name == $match_pattern ]]; then
            filtered_tests+=("$test_file")
        fi
    done
    test_files=("${filtered_tests[@]}")
fi

if [ ${#test_files[@]} -eq 0 ]; then
    echo "No test files found in $tests_dir"
    exit 1
fi

echo "Running JCC tests..."
if [ $use_leaks -eq 1 ]; then
    case "$platform" in
        macos)
            echo "Memory leak detection enabled (using 'leaks')"
            ;;
        linux)
            echo "Memory leak detection enabled (using 'valgrind')"
            ;;
        windows)
            echo "Memory leak detection enabled (using 'drmemory')"
            ;;
        *)
            echo "Warning: Memory leak detection not supported on this platform"
            use_leaks=0
            ;;
    esac
fi
if [ -n "$match_pattern" ]; then
    echo "Filtering tests matching: $match_pattern"
fi
echo "======================="
echo ""

# Run each test
for test_file in "${test_files[@]}"; do
    test_name=$(basename "$test_file")
    total=$((total + 1))

    # Check if this is a negative test (expects compilation error)
    is_negative_test=0
    if head -n 1 "$test_file" | grep -q "EXPECT_COMPILE_ERROR"; then
        is_negative_test=1
    fi

    # Check if this test expects a runtime error (e.g., division by zero detection)
    expects_runtime_error=0
    if head -n 1 "$test_file" | grep -q "EXPECT_RUNTIME_ERROR"; then
        expects_runtime_error=1
    fi

    # Run the test and capture output and exit code
    if [ $use_leaks -eq 1 ]; then
        # Run with platform-specific leak detection tool
        case "$platform" in
            macos)
                # macOS: use 'leaks' command
                output=$(leaks -atExit -- "$jcc" -I./include "${jcc_args[@]}" "$test_file" 2>&1)
                exit_code=$?
                # Check if leaks were detected (leaks prints "0 leaks" if clean)
                if echo "$output" | grep -q "0 leaks"; then
                    is_leaking=0
                else
                    is_leaking=1
                fi
                ;;
            linux)
                # Linux: use valgrind
                output=$(valgrind --leak-check=full --error-exitcode=1 --quiet "$jcc" -I./include "${jcc_args[@]}" "$test_file" 2>&1)
                exit_code=$?
                # valgrind exits with error code 1 if leaks detected (when --error-exitcode=1 is set)
                # Check for leak summary in output
                if echo "$output" | grep -q "no leaks are possible\|All heap blocks were freed"; then
                    is_leaking=0
                elif echo "$output" | grep -q "definitely lost\|indirectly lost\|possibly lost"; then
                    is_leaking=1
                else
                    is_leaking=0
                fi
                ;;
            windows)
                # Windows: use Dr. Memory
                output=$(drmemory -batch -quiet -- "$jcc" -I./include "${jcc_args[@]}" "$test_file" 2>&1)
                exit_code=$?
                # Dr. Memory reports leaks in its output
                if echo "$output" | grep -q "0 unique,.*0 total"; then
                    is_leaking=0
                elif echo "$output" | grep -q "LEAK\|UNADDRESSABLE ACCESS"; then
                    is_leaking=1
                else
                    is_leaking=0
                fi
                ;;
            *)
                # Unsupported platform - run normally
                output=$("$jcc" -I./include "${jcc_args[@]}" "$test_file" 2>&1)
                exit_code=$?
                is_leaking=0
                ;;
        esac
    else
        # Normal run - capture stderr to check for compilation errors
        output=$("$jcc" -I./include "${jcc_args[@]}" "$test_file" 2>&1)
        exit_code=$?
        is_leaking=0
    fi

    # Check if output contains compilation error indicators
    has_compile_error=0
    if echo "$output" | grep -q "error generated\|cannot open file\|expected.*got"; then
        has_compile_error=1
    fi

    # Crash detection:
    # Only check for specific crash signals, not all exit codes > 128
    # 134 = 128+6 (SIGABRT), 139 = 128+11 (SIGSEGV), 136 = 128+8 (SIGFPE), 141 = 128+13 (SIGPIPE)
    # Other high exit codes (like 230, 200) are legitimate test return values
    if [ $exit_code -eq 134 ] || [ $exit_code -eq 139 ] || [ $exit_code -eq 136 ] || [ $exit_code -eq 141 ]; then
        crashed=$((crashed + 1))
        crashed_tests+=("$test_name (exit code: $exit_code)")
        echo "üí• $test_name (CRASHED: exit code $exit_code)"
    elif [ $has_compile_error -eq 1 ]; then
        # Compilation error detected
        if [ $is_negative_test -eq 1 ]; then
            # Negative test that correctly failed compilation
            negative_passed=$((negative_passed + 1))
            echo "‚úì $test_name (correctly rejected invalid code)"
        else
            # Unexpected compilation error
            failed=$((failed + 1))
            failed_tests+=("$test_name (COMPILATION ERROR)")
            echo "‚úó $test_name (COMPILATION ERROR)"
            # Print first few lines of error
            echo "$output" | head -n 3 | sed 's/^/  /'
        fi
    elif [ $is_leaking -eq 1 ]; then
        failed=$((failed + 1))
        failed_tests+=("$test_name (MEMORY LEAK)")
        echo "üíß $test_name (MEMORY LEAK)"
        # Print first few lines of leak report
        echo "$output" | grep "Leak:" | head -n 3 | sed 's/^/  /'
    elif [ $exit_code -eq 42 ]; then
        # Exit code 42 indicates successful test execution
        passed=$((passed + 1))
        echo "‚úì $test_name"
    elif [ $expects_runtime_error -eq 1 ] && [ $exit_code -eq 255 ]; then
        # Runtime error test that correctly detected the error
        negative_passed=$((negative_passed + 1))
        echo "‚úì $test_name (correctly detected runtime error)"
    else
        # Any exit code other than 42 indicates test failure
        failed=$((failed + 1))
        failed_tests+=("$test_name (exit code: $exit_code)")
        echo "‚úó $test_name (expected exit code 42, got: $exit_code)"
    fi
done

echo ""
echo "======================="
echo "Test Results Summary"
echo "======================="
echo "Total:          $total"
echo "Passed:         $passed"
echo "Negative tests: $negative_passed (correctly rejected invalid code)"
echo "Failed:         $failed"
echo "Crashed:        $crashed"

if [ $crashed -gt 0 ]; then
    echo ""
    echo "‚ö†Ô∏è  CRASHED TESTS (segfaults/aborts):"
    for test in "${crashed_tests[@]}"; do
        echo "  - $test"
    done
fi

if [ $failed -gt 0 ]; then
    echo ""
    echo "Failed tests:"
    for test in "${failed_tests[@]}"; do
        echo "  - $test"
    done
fi

if [ $failed -gt 0 ] || [ $crashed -gt 0 ]; then
    exit 1
else
    echo ""
    echo "All tests passed! üéâ"
    exit 0
fi
