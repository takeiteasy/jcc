#!/usr/bin/env bash
# Test runner for JCC 
# Runs all test_*.c files in tests/ directory and reports results

script_dir=$(cd "$(dirname "$0")" && pwd)
jcc="$script_dir/jcc"
tests_dir="$script_dir/tests"

# Check if jcc exists
if [ ! -f "$jcc" ]; then
    echo "Error: jcc executable not found. Please run 'make' first."
    exit 1
fi

# Check if tests directory exists
if [ ! -d "$tests_dir" ]; then
    echo "Error: tests directory not found."
    exit 1
fi

# Initialize counters
passed=0
failed=0
crashed=0
total=0
negative_passed=0
negative_failed=0
failed_tests=()
crashed_tests=()

# Get all test files
test_files=()
while IFS= read -r file; do
    [ -n "$file" ] && test_files+=("$file")
done < <(find "$tests_dir" -name "test_*.c" -maxdepth 1 | sort)

# Parse arguments
use_leaks=0
jcc_args=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --leaks)
            use_leaks=1
            shift
            ;;
        *)
            jcc_args+=("$1")
            shift
            ;;
    esac
done

if [ ${#test_files[@]} -eq 0 ]; then
    echo "No test files found in $tests_dir"
    exit 1
fi

echo "Running JCC tests..."
if [ $use_leaks -eq 1 ]; then
    echo "Memory leak detection enabled (using 'leaks')"
fi
echo "======================="
echo ""

# Run each test
for test_file in "${test_files[@]}"; do
    test_name=$(basename "$test_file")
    total=$((total + 1))

    # Check if this is a negative test (expects compilation error)
    is_negative_test=0
    if head -n 1 "$test_file" | grep -q "EXPECT_COMPILE_ERROR"; then
        is_negative_test=1
    fi

    # Run the test and capture output and exit code
    if [ $use_leaks -eq 1 ]; then
        # Run with leaks detection
        # Capture output to check for leaks
        output=$(leaks -atExit -- "$jcc" -I./include "${jcc_args[@]}" "$test_file" 2>&1)
        exit_code=$?

        # Check if leaks were detected (leaks usually prints "0 leaks" if clean)
        if echo "$output" | grep -q "0 leaks"; then
            is_leaking=0
        else
            is_leaking=1
        fi
    else
        # Normal run - capture stderr to check for compilation errors
        output=$("$jcc" -I./include "${jcc_args[@]}" "$test_file" 2>&1)
        exit_code=$?
        is_leaking=0
    fi

    # Check if output contains compilation error indicators
    has_compile_error=0
    if echo "$output" | grep -q "error generated\|cannot open file\|expected.*got"; then
        has_compile_error=1
    fi

    # Crash detection:
    # Only check for specific crash signals, not all exit codes > 128
    # 134 = 128+6 (SIGABRT), 139 = 128+11 (SIGSEGV), 136 = 128+8 (SIGFPE), 141 = 128+13 (SIGPIPE)
    # Other high exit codes (like 230, 200) are legitimate test return values
    if [ $exit_code -eq 134 ] || [ $exit_code -eq 139 ] || [ $exit_code -eq 136 ] || [ $exit_code -eq 141 ]; then
        crashed=$((crashed + 1))
        crashed_tests+=("$test_name (exit code: $exit_code)")
        echo "üí• $test_name (CRASHED: exit code $exit_code)"
    elif [ $has_compile_error -eq 1 ]; then
        # Compilation error detected
        if [ $is_negative_test -eq 1 ]; then
            # Negative test that correctly failed compilation
            negative_passed=$((negative_passed + 1))
            echo "‚úì $test_name (correctly rejected invalid code)"
        else
            # Unexpected compilation error
            failed=$((failed + 1))
            failed_tests+=("$test_name (COMPILATION ERROR)")
            echo "‚úó $test_name (COMPILATION ERROR)"
            # Print first few lines of error
            echo "$output" | head -n 3 | sed 's/^/  /'
        fi
    elif [ $is_leaking -eq 1 ]; then
        failed=$((failed + 1))
        failed_tests+=("$test_name (MEMORY LEAK)")
        echo "üíß $test_name (MEMORY LEAK)"
        # Print first few lines of leak report
        echo "$output" | grep "Leak:" | head -n 3 | sed 's/^/  /'
    elif [ $exit_code -eq 42 ]; then
        # Exit code 42 indicates successful test execution
        passed=$((passed + 1))
        echo "‚úì $test_name"
    else
        # Any exit code other than 42 indicates test failure
        failed=$((failed + 1))
        failed_tests+=("$test_name (exit code: $exit_code)")
        echo "‚úó $test_name (expected exit code 42, got: $exit_code)"
    fi
done

echo ""
echo "======================="
echo "Test Results Summary"
echo "======================="
echo "Total:          $total"
echo "Passed:         $passed"
echo "Negative tests: $negative_passed (correctly rejected invalid code)"
echo "Failed:         $failed"
echo "Crashed:        $crashed"

if [ $crashed -gt 0 ]; then
    echo ""
    echo "‚ö†Ô∏è  CRASHED TESTS (segfaults/aborts):"
    for test in "${crashed_tests[@]}"; do
        echo "  - $test"
    done
fi

if [ $failed -gt 0 ]; then
    echo ""
    echo "Failed tests:"
    for test in "${failed_tests[@]}"; do
        echo "  - $test"
    done
fi

if [ $failed -gt 0 ] || [ $crashed -gt 0 ]; then
    exit 1
else
    echo ""
    echo "All tests passed! üéâ"
    exit 0
fi
