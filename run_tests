#!/usr/bin/env bash
# Test runner for JCC 
# Runs all test_*.c files in tests/ directory and reports results

script_dir=$(cd "$(dirname "$0")" && pwd)
jcc="$script_dir/jcc"
tests_dir="$script_dir/tests"

# Check if jcc exists
if [ ! -f "$jcc" ]; then
    echo "Error: jcc executable not found. Please run 'make' first."
    exit 1
fi

# Check if tests directory exists
if [ ! -d "$tests_dir" ]; then
    echo "Error: tests directory not found."
    exit 1
fi

# Initialize counters
passed=0
failed=0
crashed=0
total=0
failed_tests=()
crashed_tests=()

# Get all test files
test_files=()
while IFS= read -r file; do
    [ -n "$file" ] && test_files+=("$file")
done < <(find "$tests_dir" -name "test_*.c" -maxdepth 1 | sort)

# Parse arguments
use_leaks=0
jcc_args=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --leaks)
            use_leaks=1
            shift
            ;;
        *)
            jcc_args+=("$1")
            shift
            ;;
    esac
done

if [ ${#test_files[@]} -eq 0 ]; then
    echo "No test files found in $tests_dir"
    exit 1
fi

echo "Running JCC tests..."
if [ $use_leaks -eq 1 ]; then
    echo "Memory leak detection enabled (using 'leaks')"
fi
echo "======================="
echo ""

# Run each test
for test_file in "${test_files[@]}"; do
    test_name=$(basename "$test_file")
    total=$((total + 1))
    
    # Run the test and capture exit code
    if [ $use_leaks -eq 1 ]; then
        # Run with leaks detection
        # Capture output to check for leaks
        output=$(leaks -atExit -- "$jcc" -I./include "${jcc_args[@]}" "$test_file" 2>&1)
        exit_code=$?
        
        # Check if leaks were detected (leaks usually prints "0 leaks" if clean)
        if echo "$output" | grep -q "0 leaks"; then
            is_leaking=0
        else
            is_leaking=1
        fi
    else
        # Normal run
        "$jcc" -I./include "${jcc_args[@]}" "$test_file" >/dev/null 2>&1
        exit_code=$?
        is_leaking=0
    fi

    # Crash detection:
    # Only check for specific crash signals, not all exit codes > 128
    # 134 = 128+6 (SIGABRT), 139 = 128+11 (SIGSEGV), 136 = 128+8 (SIGFPE), 141 = 128+13 (SIGPIPE)
    # Other high exit codes (like 230, 200) are legitimate test return values
    if [ $exit_code -eq 134 ] || [ $exit_code -eq 139 ] || [ $exit_code -eq 136 ] || [ $exit_code -eq 141 ]; then
        crashed=$((crashed + 1))
        crashed_tests+=("$test_name (exit code: $exit_code)")
        echo "üí• $test_name (CRASHED: exit code $exit_code)"
    elif [ $is_leaking -eq 1 ]; then
        failed=$((failed + 1))
        failed_tests+=("$test_name (MEMORY LEAK)")
        echo "üíß $test_name (MEMORY LEAK)"
        # Print first few lines of leak report
        echo "$output" | grep "Leak:" | head -n 3 | sed 's/^/  /'
    elif [ $exit_code -ne 0 ]; then
        # Non-zero exit code indicates successful test execution
        # JCC tests return their result as exit code (e.g., 42, 30, etc.)
        passed=$((passed + 1))
        echo "‚úì $test_name (exit code: $exit_code)"
    else
        # Exit code 0 is unexpected (tests should return non-zero)
        failed=$((failed + 1))
        failed_tests+=("$test_name")
        echo "‚úó $test_name (unexpected exit code: 0)"
    fi
done

echo ""
echo "======================="
echo "Test Results Summary"
echo "======================="
echo "Total:   $total"
echo "Passed:  $passed"
echo "Failed:  $failed"
echo "Crashed: $crashed"

if [ $crashed -gt 0 ]; then
    echo ""
    echo "‚ö†Ô∏è  CRASHED TESTS (segfaults/aborts):"
    for test in "${crashed_tests[@]}"; do
        echo "  - $test"
    done
fi

if [ $failed -gt 0 ]; then
    echo ""
    echo "Failed tests:"
    for test in "${failed_tests[@]}"; do
        echo "  - $test"
    done
fi

if [ $failed -gt 0 ] || [ $crashed -gt 0 ]; then
    exit 1
else
    echo ""
    echo "All tests passed! üéâ"
    exit 0
fi
